'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enablePackage = undefined;

var enablePackage = exports.enablePackage = function () {
  var _ref = _asyncToGenerator(function* (packageName) {
    if (atom.packages.isPackageDisabled(packageName)) {
      atom.packages.enablePackage(packageName);
    }
    if (!atom.packages.isPackageLoaded(packageName)) {
      atom.packages.loadPackage(packageName);
    }
    if (!atom.packages.isPackageActive(packageName)) {
      yield atom.packages.activatePackage(packageName);
    }
  });

  return function enablePackage(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.apmInstall = apmInstall;
exports.getDependencies = getDependencies;

var _sbExec = require('sb-exec');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var VALID_TICKS = new Set(['âœ“', 'done']);
var VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/;

function apmInstall(dependencies, progressCallback) {
  var errors = new Map();
  return Promise.all(dependencies.map(function (dependency) {
    return (0, _sbExec.exec)(atom.packages.getApmPath(), ['install', dependency, '--production', '--color', 'false'], {
      stream: 'both',
      ignoreExitCode: true
    }).then(function (output) {
      var successful = VALIDATION_REGEXP.test(output.stdout) && VALID_TICKS.has(VALIDATION_REGEXP.exec(output.stdout)[2]);
      progressCallback(dependency, successful);
      if (!successful) {
        var error = new Error('Error installing dependency: ' + dependency);
        error.stack = output.stderr;
        throw error;
      }
    }).catch(function (error) {
      errors.set(dependency, error);
    });
  })).then(function () {
    return errors;
  });
}

function getDependencies(packageName) {
  var toReturn = [];
  var packageModule = atom.packages.getLoadedPackage(packageName);
  var packageDependencies = packageModule && packageModule.metadata['package-deps'];

  if (packageDependencies) {
    var _arr = packageDependencies;

    for (var _i = 0; _i < _arr.length; _i++) {
      var entry = _arr[_i];
      if (__steelbrain_package_deps.has(entry) || atom.packages.resolvePackagePath(entry)) {
        continue;
      }
      __steelbrain_package_deps.add(entry);
      toReturn.push(entry);
    }
  } else {
    console.error('[Package-Deps] Unable to get loaded package \'' + packageName + '\'');
  }

  return toReturn;
}